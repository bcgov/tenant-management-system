name: .Helm Deployer

on:
  workflow_call:
    inputs:
      ### Required
      # Only secrets!

      ### Typical / recommended
      atomic:
        description: Atomic deployment?  That means fail all or nothing
        default: false
        required: false
        type: boolean
      directory:
        description: Chart directory
        default:  'charts/app'
        required: false
        type: string
      environment:
        description: Environment name; omit for PRs
        required: false
        type: string
      oc_server:
        default: https://api.silver.devops.gov.bc.ca:6443
        description: OpenShift server
        required: false
        type: string
      params:
        description: Extra parameters to pass to helm upgrade
        required: false
        type: string
      tags:
        description: Specify a tag to deploy; defaults to PR number
        required: false
        type: string
      triggers:
        description: Paths used to trigger a deployment; e.g. ('./backend/' './frontend/)
        required: false
        type: string
      db_user:
        description: The database user
        required: false
        default: 'app'
        type: string
      debug:
        description: Debug mode
        default: false
        required: false
        type: boolean
      release_name:
        required: true
        type: string
        description: "Release name (e.g., tenant-management-system-dev)"

      ### Usually a bad idea / not recommended
      timeout-minutes:
        description: 'Timeout minutes'
        default: 10
        required: false
        type: number
      values:
        description: 'Values file'
        default: 'values.yaml'
        required: false
        type: string
      deployment_url:
        description: 'Deployment URL; used for environments'
        required: true
        type: string
      db_triggers:
        description: Paths used to trigger a database deployment; e.g. ('charts/crunchy/')
        required: false
        type: string

    outputs:
      tag:
        description: 'Which tag was used for deployment?'
        value: ${{ jobs.deploy.outputs.tag }}
      triggered:
        description: 'Has a deployment has been triggered?'
        value: ${{ jobs.deploy.outputs.triggered }}

    secrets:
      oc_namespace:
        description: OpenShift namespace
        required: true
      oc_token:
        description: OpenShift token
        required: true
      bcgov_sso_api_client_id:
        required: true
      bcgov_sso_api_client_secret:
        required: true
      vite_keycloak_client_id:
        required: true

permissions:
  contents: read
  deployments: write

jobs:
  deploy:
    name: Stack
    environment:
      name: ${{ inputs.environment }}
      url: ${{ inputs.deployment_url }}
    runs-on: ubuntu-24.04
    outputs:
      tag: ${{ inputs.tag || steps.pr.outputs.pr }}
      triggered: ${{ steps.deploy.outputs.triggered }}
    steps:
      - name: Deploy Crunchy Database
        id: deploy_crunchy
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ vars.oc_server }}
          triggers: ${{ inputs.db_triggers }}
          commands: |
            # Set database cluster name with proper fallback
            RELEASE_NAME="${{ steps.vars.outputs.release }}"
            if [[ -z "$RELEASE_NAME" ]]; then
              RELEASE_NAME="${{ github.event.repository.name }}-${{ inputs.environment || 'dev' }}"
            fi
            DB_CLUSTER_NAME="${RELEASE_NAME}-crunchy"
            echo "Release name: $RELEASE_NAME"
            echo "Database cluster name: $DB_CLUSTER_NAME"
            
            # Clean up any existing problematic cluster
            if oc get postgrescluster $DB_CLUSTER_NAME &>/dev/null; then
              echo "Found existing PostgreSQL cluster $DB_CLUSTER_NAME"
              
              # Check for PVC issues in events
              PVC_ISSUES=$(oc get events --field-selector involvedObject.name=$DB_CLUSTER_NAME-repo-host-0 2>/dev/null | grep -i "persistentvolumeclaim.*not found" || echo "")
              
              if [[ -n "$PVC_ISSUES" ]]; then
                echo "⚠️ Found PVC issues. Cleaning up and recreating..."
                
                # Delete the problematic cluster
                oc delete postgrescluster $DB_CLUSTER_NAME --ignore-not-found=true
                
                # Wait for cleanup
                echo "Waiting for cleanup..."
                sleep 30
                
                # Clean up any stuck resources
                oc delete pvc -l postgres-operator.crunchydata.com/cluster=$DB_CLUSTER_NAME --ignore-not-found=true
                oc delete pods -l postgres-operator.crunchydata.com/cluster=$DB_CLUSTER_NAME --ignore-not-found=true
                
                # Wait for complete cleanup
                sleep 10
              else
                # Check if it's healthy
                STATUS=$(oc get postgrescluster $DB_CLUSTER_NAME -o jsonpath='{.status.state}' 2>/dev/null || echo "Unknown")
                echo "Current status: $STATUS"
                
                if [[ "$STATUS" == "Initialized" ]]; then
                  echo "✅ Database cluster is healthy and ready"
                  echo "release=$DB_CLUSTER_NAME" >> $GITHUB_OUTPUT
                  exit 0
                fi
              fi
            fi
            
            # Create PostgreSQL cluster without complex backups
            echo "Creating simplified PostgreSQL cluster $DB_CLUSTER_NAME..."
            
            # Set environment-specific values optimized for full stack
            if [[ "${{ inputs.environment }}" == "" ]]; then
              # PR environment - minimal resources
              STORAGE_SIZE="1Gi"     # Small for PRs
              BACKUP_SIZE="500Mi"    # Even smaller backup
            else
              # Test/Prod environment - optimized for 5Gi quota with frontend/backend
              STORAGE_SIZE="2Gi"     # Database gets 2Gi
              BACKUP_SIZE="1Gi"      # Backup gets 1Gi (total = 3Gi, leaves 2Gi free)
            fi
          
            echo "Using storage size: $STORAGE_SIZE, backup size: $BACKUP_SIZE"
            echo "Optimized for full stack deployment (frontend + backend + database)"
            
            # Create PostgreSQL cluster with reduced storage for full stack
            cat <<EOF | oc apply -f -
            apiVersion: postgres-operator.crunchydata.com/v1beta1
            kind: PostgresCluster
            metadata:
              name: $DB_CLUSTER_NAME
              labels:
                app.kubernetes.io/name: postgres
                app.kubernetes.io/instance: $RELEASE_NAME
            spec:
              image: registry.developers.crunchydata.com/crunchydata/crunchy-postgres:ubi8-15.3-2512
              postgresVersion: 15

              instances:
                - name: instance1
                  replicas: 1

                  # Reduced resources for database to leave room for apps
                  resources:
                    requests:
                      cpu: "150m"      # Reduced from 250m
                      memory: "256Mi"  # Reduced from 512Mi
                    limits:
                      cpu: "500m"     # Reduced from 1000m
                      memory: "512Mi"  # Reduced from 1Gi

                  dataVolumeClaimSpec:
                    accessModes:
                      - "ReadWriteOnce"
                    resources:
                      requests:
                        storage: $STORAGE_SIZE
                    storageClassName: "netapp-file-standard"

              users:
                - name: ${{ inputs.db_user }}
                  databases:
                    - app
                  options: "SUPERUSER"

              # Minimal backup configuration
              backups:
                pgbackrest:
                  image: registry.developers.crunchydata.com/crunchydata/crunchy-pgbackrest:ubi8-2.45-2512

                  # Required repos section with minimal backup storage
                  repos:
                    - name: repo1
                      volume:
                        volumeClaimSpec:
                          accessModes:
                            - "ReadWriteOnce"
                          resources:
                            requests:
                              storage: $BACKUP_SIZE
                          storageClassName: "netapp-file-standard"

                  # Minimal backup settings to save space
                  global:
                    repo1-retention-full: "1"    # Keep only 1 full backup
                    repo1-retention-diff: "0"    # No differential backups

                  # Manual backup options
                  manual:
                    repoName: repo1
                    options:
                      - --type=full
            EOF
            
            echo "PostgreSQL cluster created, waiting for initialization..."
            
            # Wait for PostgreSQL cluster to be ready with better error handling
            echo "Waiting for PostgreSQL cluster to be ready..."
            for i in {1..30}; do
              # Check if cluster still exists
              if ! oc get postgrescluster $DB_CLUSTER_NAME &>/dev/null; then
                echo "❌ PostgreSQL cluster was deleted or failed to create"
                exit 1
              fi
              
              STATUS=$(oc get postgrescluster $DB_CLUSTER_NAME -o jsonpath='{.status.state}' 2>/dev/null || echo "NoStatus")
              
              if [[ "$STATUS" == "Initialized" ]]; then
                echo "✅ PostgreSQL cluster is ready!"
                
                # Verify database user exists
                USER_SECRET="${DB_CLUSTER_NAME}-pguser-${{ inputs.db_user }}"
                if oc get secret $USER_SECRET &>/dev/null; then
                  echo "✅ Database user secret exists: $USER_SECRET"
                  
                  # Show connection details
                  echo "Database connection details:"
                  echo "Host: ${DB_CLUSTER_NAME}-pgbouncer"
                  echo "Port: 5432"
                  echo "Database: app"
                  echo "User: ${{ inputs.db_user }}"
                  
                else
                  echo "⚠️ Database user secret not found: $USER_SECRET"
                  echo "Available postgres secrets:"
                  oc get secrets | grep $DB_CLUSTER_NAME | head -5
                fi
                
                # Set output for the main deployment
                echo "release=$DB_CLUSTER_NAME" >> $GITHUB_OUTPUT
                exit 0
                
              elif [[ "$STATUS" == "NoStatus" || "$STATUS" == "" ]]; then
                echo "Attempt $i/30: No status yet, checking pods..."
                
                # Check for specific pod issues
                PODS=$(oc get pods -l postgres-operator.crunchydata.com/cluster=$DB_CLUSTER_NAME --no-headers 2>/dev/null)
                if [[ -n "$PODS" ]]; then
                  echo "$PODS"
                else
                  echo "No pods found yet"
                fi
                
              else
                echo "Attempt $i/30: Status is '$STATUS', waiting 20 seconds..."
              fi
              
              # Check for PVC errors at regular intervals
              if [[ $((i % 5)) -eq 0 ]]; then
                echo "Checking for PVC issues:"
                PVC_ERRORS=$(oc get events --field-selector reason=FailedScheduling 2>/dev/null | grep -i "persistentvolumeclaim.*not found" | tail -3 || echo "No PVC errors found")
                echo "$PVC_ERRORS"
              fi
              
              sleep 20
            done
            
            # If we get here, timeout occurred
            echo "❌ Timeout waiting for PostgreSQL cluster to be ready"
            echo "Final status check:"
            oc get postgrescluster $DB_CLUSTER_NAME -o yaml | grep -A 20 "status:" || echo "No status available"
            echo ""
            echo "Pod status:"
            oc get pods -l postgres-operator.crunchydata.com/cluster=$DB_CLUSTER_NAME
            echo ""
            echo "Recent events:"
            oc get events --sort-by='.lastTimestamp' | grep $DB_CLUSTER_NAME | tail -5
            exit 1

      # Variables
      - if: inputs.tag  == ''
        id: pr
        uses: bcgov/action-get-pr@21f9351425cd55a98e869ee28919a512aa30647d # v0.0.1

      - id: vars
        run: |
          # Vars: tag and release

          # Tag defaults to PR number, but can be overridden by inputs.tag
          tag=${{ inputs.tag || steps.pr.outputs.pr }}

          # Release name includes run numbers to ensure uniqueness
          release=${{ github.event.repository.name }}-${{ inputs.environment || steps.pr.outputs.pr || inputs.tag }}
          
          # version, to support helm packaging for non-pr based releases (workflow_dispatch). default to 1.0.0+github run number
          version=1.0.0+${{ github.run_number }}
          
            # Summary
          echo "tag=${tag}"
          echo "release=${release}"
          echo "version=${version}"

          # Output
          echo "tag=${tag}" >> $GITHUB_OUTPUT
          echo "release=${release}" >> $GITHUB_OUTPUT
          echo "version=${version}" >> $GITHUB_OUTPUT

      - name: Stop pre-existing deployments on PRs (status = pending-upgrade)
        if: github.event_name == 'pull_request'
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd # v1.2.3
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ vars.oc_server }}
          triggers: ${{ inputs.triggers }}
          commands: |
            # Interrupt any previous deployments (PR only)
            PREVIOUS=$(helm status ${{ steps.vars.outputs.release }} -o json | jq .info.status || true)
            if [[ ${PREVIOUS} =~ pending ]]; then
              echo "Rollback triggered"
              helm rollback ${{ steps.vars.outputs.release }} || \
                helm uninstall ${{ steps.vars.outputs.release }}
            fi

      - uses: actions/checkout@v4
      - name: Debug Values File
        if: inputs.debug == 'true'
        run: ls -l charts/crunchy/values.yml

      - name: Start deployment
        uses: bobheadxi/deployments@v1.4.0
        id: deployment
        with:
          step: start
          token: ${{ github.token }}
          env: ${{ inputs.environment || 'dev' }}
          desc: "Starting deployment..."

      - name: Helm Deploy
        id: deploy
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd # v1.2.3
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ vars.oc_server }}
          triggers: ${{ inputs.triggers }}
          ref: ${{ github.ref }}
          commands: |
            # Deploy

            # If directory provided, cd to it
            [ -z "${{ inputs.directory }}" ]|| cd ${{ inputs.directory }}

            # Helm package
            sed -i 's/^name:.*/name: ${{ github.event.repository.name }}/' Chart.yaml
            helm package -u . --app-version="tag-${{ steps.vars.outputs.tag }}_run-${{ github.run_number }}" --version=${{ steps.pr.outputs.pr || steps.vars.outputs.version }}
            # print the values.yaml file to see the values being used
            # Helm upgrade/rollout
            helm upgrade \
              --set-string global.repository=${{ github.repository }} \
              --set-string global.tag="${{ steps.vars.outputs.tag }}" \
              --set-string global.config.databaseUser="${{ inputs.db_user }}" \
              --set-string global.config.nodeEnv=${{ (inputs.environment == 'prod' || inputs.environment == 'production') && 'production' || (inputs.environment == 'test' && 'test' || 'development') }} \
              --set-string global.databaseAlias="${{ steps.deploy_crunchy.outputs.release }}-crunchy" \
              ${{ inputs.params }} \
              --install --wait ${{ inputs.atomic && '--atomic' || '' }} ${{ steps.vars.outputs.release }} \
              --timeout ${{ inputs.timeout-minutes }}m \
              --values ${{ inputs.values }} \
              ./${{ github.event.repository.name }}-${{ steps.pr.outputs.pr || steps.vars.outputs.version }}.tgz

            # Helm release history
            helm history ${{ steps.vars.outputs.release }}

            # Completed pod cleanup
            oc delete po --field-selector=status.phase==Succeeded || true

      - name: Update secrets
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd # v1.2.3
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ vars.oc_server }}
          commands: |
            # Get release name
            RELEASE="${{ inputs.release_name }}"
            
            # Check if backend secret exists, create if it doesn't
            if ! oc get secret $RELEASE-backend &> /dev/null; then
              echo "Creating missing backend secret $RELEASE-backend"
              oc create secret generic $RELEASE-backend \
                --from-literal=BCGOV_SSO_API_CLIENT_ID="placeholder" \
                --from-literal=BCGOV_SSO_API_CLIENT_SECRET="placeholder" \
                --from-literal=ISSUER="placeholder" \
                --from-literal=JWKS_URI="placeholder"
            fi
            
            # Update secrets with real values
            echo "Patching secret $RELEASE-backend"
            
            # Update client ID
            CLIENT_ID=$(echo -n "${{ secrets.bcgov_sso_api_client_id }}" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"BCGOV_SSO_API_CLIENT_ID":"'$CLIENT_ID'"}}'
            
            # Update client secret 
            CLIENT_SECRET=$(echo -n "${{ secrets.bcgov_sso_api_client_secret }}" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"BCGOV_SSO_API_CLIENT_SECRET":"'$CLIENT_SECRET'"}}'
            
            # Set appropriate login proxy URL based on environment
            if [[ "${{ inputs.environment }}" == "prod" ]]; then
              LOGIN_PROXY="loginproxy.gov.bc.ca"
              ISSUER="https://loginproxy.gov.bc.ca/auth/realms/standard"
              JWKS_URI="https://loginproxy.gov.bc.ca/auth/realms/standard/protocol/openid-connect/certs"
            elif [[ "${{ inputs.environment }}" == "test" ]]; then
              LOGIN_PROXY="test.loginproxy.gov.bc.ca"  
              ISSUER="https://test.loginproxy.gov.bc.ca/auth/realms/standard"
              JWKS_URI="https://test.loginproxy.gov.bc.ca/auth/realms/standard/protocol/openid-connect/certs"
            else
              LOGIN_PROXY="dev.loginproxy.gov.bc.ca"
              ISSUER="https://dev.loginproxy.gov.bc.ca/auth/realms/standard"
              JWKS_URI="https://dev.loginproxy.gov.bc.ca/auth/realms/standard/protocol/openid-connect/certs"
            fi

            # Update issuer
            ISSUER_B64=$(echo -n "$ISSUER" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"ISSUER":"'$ISSUER_B64'"}}'
            
            # Update jwks uri
            JWKS_URI_B64=$(echo -n "$JWKS_URI" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"JWKS_URI":"'$JWKS_URI_B64'"}}'
            
            # Check if deployment exists first
            if oc get deployment/$RELEASE-backend &>/dev/null; then
              echo "Restarting deployment $RELEASE-backend"
              oc rollout restart deployment/$RELEASE-backend
              echo "Waiting for backend deployment to complete..."
              oc rollout status deployment/$RELEASE-backend --timeout=300s
            else
              echo "Warning: Deployment $RELEASE-backend not found"
            fi

            # Check if frontend ConfigMap exists, create if it doesn't
            if ! oc get configmap $RELEASE-frontend-config &> /dev/null; then
              echo "Creating missing frontend ConfigMap $RELEASE-frontend-config"
              oc create configmap $RELEASE-frontend-config --from-literal=placeholder=placeholder
            fi

            # Update frontend ConfigMap
            echo "Patching ConfigMap $RELEASE-frontend-config"

            # Create a new default.json content with real values
            CONFIG_JSON=$(cat <<EOF
            {
              "api": {
                "baseUrl": "/api/v1"
              },
              "oidc": {
                "clientId": "${{ secrets.vite_keycloak_client_id }}",
                "realm": "standard",
                "serverUrl": "https://$LOGIN_PROXY/auth",
                "logoutUrl": "https://$LOGIN_PROXY/auth/realms/standard/protocol/openid-connect/logout"
              }
            }
            EOF
            )

            # Create a temporary file with the JSON content
            echo "$CONFIG_JSON" > default.json

            # Force delete and recreate the ConfigMap
            oc delete configmap $RELEASE-frontend-config --ignore-not-found
            oc create configmap $RELEASE-frontend-config --from-file=default.json
            
            # Clean up the temporary file
            rm default.json

            # Replace the pod instead of restarting to ensure ConfigMap is refreshed
            if oc get deployment/$RELEASE-frontend &>/dev/null; then
              oc delete pods -l app.kubernetes.io/instance=$RELEASE-frontend
              echo "Waiting for frontend deployment to complete..."
              oc rollout status deployment/$RELEASE-frontend --timeout=300s
            else
              echo "Warning: Deployment $RELEASE-frontend not found"
            fi

      - name: Update deployment status
        uses: bobheadxi/deployments@v1.4.0
        if: always() && steps.deployment.outputs.deployment_id
        with:
          step: finish
          token: ${{ github.token }}
          status: ${{ job.status }}
          env: ${{ inputs.environment || 'dev' }}
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
          env_url: ${{ inputs.deployment_url }}

      - name: Log deployment status (fallback)
        if: always() && !steps.deployment.outputs.deployment_id
        run: |
          echo "⚠️ Deployment tracking was not initialized properly"
          echo "Job status: ${{ job.status }}"
          echo "Environment: ${{ inputs.environment || 'dev' }}"
          echo "URL: ${{ inputs.deployment_url }}"