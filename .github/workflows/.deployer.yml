name: .Helm Deployer

on:
  workflow_call:
    inputs:
      ### Required
      # Only secrets!

      ### Typical / recommended
      atomic:
        description: Atomic deployment?  That means fail all or nothing
        default: false
        required: false
        type: boolean
      directory:
        description: Chart directory
        default: 'charts/app'
        required: false
        type: string
      environment:
        description: Environment name; omit for PRs
        required: false
        type: string
      oc_server:
        default: https://api.silver.devops.gov.bc.ca:6443
        description: OpenShift server
        required: false
        type: string
      params:
        description: Extra parameters to pass to helm upgrade
        required: false
        type: string
      tags:
        description: Specify a tag to deploy; defaults to PR number
        required: false
        type: string
      triggers:
        description: Paths used to trigger a deployment; e.g. ('./backend/' './frontend/')
        required: false
        type: string
      db_user:
        description: The database user
        required: false
        default: 'app'
        type: string
      debug:
        description: Debug mode
        default: false
        required: false
        type: boolean
      release_name:
        required: true
        type: string
        description: "Release name (e.g., tenant-management-system-dev)"
      preserve_database:
        description: "Preserve existing database data (true for test/prod, false for PRs)"
        default: true
        required: false
        type: boolean

      ### Usually a bad idea / not recommended
      timeout-minutes:
        description: 'Timeout minutes'
        default: 15  # Reduced from 25 to fail faster
        required: false
        type: number
      values:
        description: 'Values file'
        default: 'values.yaml'
        required: false
        type: string
      deployment_url:
        description: 'Deployment URL; used for environments'
        required: true
        type: string
      db_triggers:
        description: Paths used to trigger a database deployment; e.g. ('charts/crunchy/')
        required: false
        type: string

    outputs:
      tag:
        description: 'Which tag was used for deployment?'
        value: ${{ jobs.deploy.outputs.tag }}
      triggered:
        description: 'Has a deployment has been triggered?'
        value: ${{ jobs.deploy.outputs.triggered }}

    secrets:
      oc_namespace:
        description: OpenShift namespace
        required: true
      oc_token:
        description: OpenShift token
        required: true
      bcgov_sso_api_client_id:
        required: true
      bcgov_sso_api_client_secret:
        required: true
      vite_keycloak_client_id:
        required: true

permissions:
  contents: read
  deployments: write

jobs:
  deploy:
    name: Stack
    environment:
      name: ${{ inputs.environment }}
      url: ${{ inputs.deployment_url }}
    runs-on: ubuntu-24.04
    # Add timeout to prevent jobs from hanging indefinitely
    timeout-minutes: 30
    outputs:
      tag: ${{ inputs.tag || steps.pr.outputs.pr }}
      triggered: ${{ steps.deploy.outputs.triggered }}
    steps:
      - name: Get PR number
        if: inputs.tag == ''
        id: pr
        continue-on-error: true  # Don't fail if PR detection fails
        uses: bcgov/action-get-pr@21f9351425cd55a98e869ee28919a512aa30647d

      - name: Set variables
        id: vars
        run: |
          # Simplified tag and release logic
          
          # Tag logic: latest for main/deployment-fix, PR number for actual PRs
          if [ -n "${{ inputs.tag }}" ]; then
            # Use explicit tag if provided
            tag="${{ inputs.tag }}"
          elif [ "${{ github.ref_name }}" == "main" ] || [ "${{ github.ref_name }}" == "deployment-fix" ]; then
            # Use 'latest' for main and deployment-fix branches
            tag="latest"
          elif [ -n "${{ steps.pr.outputs.pr }}" ] && [ "${{ steps.pr.outputs.pr }}" != "null" ] && [ "${{ steps.pr.outputs.pr }}" != "" ]; then
            # Use PR number for actual PR environments
            tag="pr-${{ steps.pr.outputs.pr }}"
          else
            # Final fallback
            tag="latest"
          fi

          # Release name logic - use input release_name directly
          release="${{ inputs.release_name }}"
          
          # Version for helm packaging
          version=1.0.0+${{ github.run_number }}
          
          # Summary
          echo "Branch: ${{ github.ref_name }}"
          echo "Tag: ${tag}"
          echo "Release: ${release}"
          echo "Version: ${version}"
          echo "Preserve DB: ${{ inputs.preserve_database }}"

          # Output
          echo "tag=${tag}" >> $GITHUB_OUTPUT
          echo "release=${release}" >> $GITHUB_OUTPUT
          echo "version=${version}" >> $GITHUB_OUTPUT

      - name: Force Cleanup Any Stuck Helm Operations
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ inputs.oc_server }}
          commands: |
            # Enable strict error handling
            set -euo pipefail
            
            RELEASE_NAME="${{ steps.vars.outputs.release }}"
            echo "🔄 Force cleanup of any stuck Helm operations for: $RELEASE_NAME"
            
            # Function to force cleanup stuck helm releases
            force_cleanup_helm() {
              local release_name="$1"
              echo "🧹 Starting force cleanup for release: $release_name"
            
              # Get current status if release exists
              if helm list -q | grep -q "^$release_name$"; then
                CURRENT_STATUS=$(helm status "$release_name" -o json 2>/dev/null | jq -r '.info.status' || echo "unknown")
                echo "Current status: $CURRENT_STATUS"
            
                case "$CURRENT_STATUS" in
                  "pending-install"|"pending-upgrade"|"pending-rollback"|"uninstalling")
                    echo "⚠️ Found stuck operation: $CURRENT_STATUS - forcing cleanup"
            
                    # Force delete all helm secrets for this release
                    echo "🗑️ Removing Helm secrets..."
                    kubectl delete secret -l owner=helm,name="$release_name" --ignore-not-found=true --timeout=60s || true
                    kubectl delete configmap -l owner=helm,name="$release_name" --ignore-not-found=true --timeout=60s || true
            
                    # Wait a moment for cleanup
                    sleep 5
            
                    # Verify cleanup worked
                    if helm list -q | grep -q "^$release_name$"; then
                      echo "⚠️ Release still exists after secret cleanup, attempting final removal..."
                      kubectl patch secret -l owner=helm,name="$release_name" -p '{"metadata":{"finalizers":[]}}' --ignore-not-found=true || true
                      kubectl delete secret -l owner=helm,name="$release_name" --ignore-not-found=true --force --grace-period=0 || true
                    fi
                    ;;
                  "deployed"|"failed")
                    echo "✅ Release is in stable state: $CURRENT_STATUS - no cleanup needed"
                    ;;
                  *)
                    echo "⚠️ Unknown status: $CURRENT_STATUS - will proceed with deployment"
                    ;;
                esac
              else
                echo "ℹ️ No existing release found - clean slate"
              fi
              
              # NEW: Clean up orphaned resources that prevent Helm adoption
              echo "Cleaning up orphaned ConfigMaps and resources..."
              oc delete configmap "${release_name}-frontend-config" --ignore-not-found=true || true
  
              # Clean up any resources that might conflict with Helm installation
              echo "Cleaning up any existing resources without proper Helm ownership..."
              oc delete all,configmap,secret,route -l app.kubernetes.io/instance="${release_name}" --ignore-not-found=true || true
  
            
              echo "✅ Cleanup completed for $release_name"
            }
            
            # Execute cleanup
            force_cleanup_helm "$RELEASE_NAME"

      - name: Deploy Database (Smart Preservation)
        id: deploy_database
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ inputs.oc_server }}
          commands: |
            # Enable strict error handling
            set -euo pipefail
            
            echo "🚀 DATABASE DEPLOYMENT STARTING..."
            
            # Set database configuration
            RELEASE_NAME="${{ steps.vars.outputs.release }}"
            DB_USER="${{ inputs.db_user }}"
            PRESERVE_DB="${{ inputs.preserve_database }}"
            
            echo "Release name: $RELEASE_NAME"
            echo "Database user: $DB_USER"
            echo "Preserve database: $PRESERVE_DB"
            
            # Generate a consistent password
            DB_PASSWORD=$(echo -n "${RELEASE_NAME}-${DB_USER}" | sha256sum | cut -d' ' -f1 | head -c32)
            
            # Check if database already exists
            if oc get deployment ${RELEASE_NAME}-postgres &>/dev/null; then
              echo "✅ Database deployment already exists"
            else
              echo "❌ Database deployment missing - this will be created by Helm"
            fi
            
            if oc get pvc ${RELEASE_NAME}-postgres-data &>/dev/null; then
              echo "✅ Database PVC already exists"
            else
              echo "❌ Database PVC missing - this will be created by Helm"
            fi
            
            # Ensure database secret exists
            echo "Creating/updating database secret..."
            
            # Determine the correct database host based on environment
            if [[ "${RELEASE_NAME}" == *"-pr-"* ]]; then
            # PR environments use Bitnami PostgreSQL
            DB_HOST="${RELEASE_NAME}-bitnami-pg-pr-$(echo ${RELEASE_NAME} | grep -o 'pr-[0-9]*' | cut -d'-' -f2)"
            echo "PR environment detected - using Bitnami host: $DB_HOST"
            else
            # Test/prod environments use Crunchy PostgreSQL with PgBouncer
            DB_HOST="${RELEASE_NAME}-pgbouncer"
            echo "Non-PR environment detected - using Crunchy host: $DB_HOST"
            fi
            
            oc delete secret ${RELEASE_NAME}-pguser-${DB_USER} --ignore-not-found=true
            oc create secret generic ${RELEASE_NAME}-pguser-${DB_USER} \
              --from-literal=password="$DB_PASSWORD" \
              --from-literal=username="$DB_USER" \
              --from-literal=dbname="app" \
              --from-literal=host="$DB_HOST" \
              --from-literal=port="5432"
            
            echo "✅ Database secret created/updated"

      - uses: actions/checkout@v4

      - name: Start deployment
        uses: bobheadxi/deployments@v1.4.0
        id: deployment
        with:
          step: start
          token: ${{ github.token }}
          env: ${{ inputs.environment || 'dev' }}
          desc: "Starting deployment..."

      - name: Helm Deploy with Improved Resilience
        id: deploy
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ inputs.oc_server }}
          triggers: ${{ inputs.triggers }}
          ref: ${{ github.ref }}
          commands: |
            # Enable strict error handling
            set -euo pipefail
            
            # Enhanced directory change with validation
            echo "Input directory: '${{ inputs.directory }}'"
            echo "Current working directory: $(pwd)"

            if [ -n "${{ inputs.directory }}" ] && [ "${{ inputs.directory }}" != "" ]; then
              echo "Changing to directory: ${{ inputs.directory }}"
              if [ -d "${{ inputs.directory }}" ]; then
                cd "${{ inputs.directory }}"
                echo "Successfully changed to: $(pwd)"
                echo "Directory contents:"
                ls -la
              else
                echo "ERROR: Directory '${{ inputs.directory }}' does not exist!"
                echo "Available directories in $(pwd):"
                ls -la
                exit 1
              fi
            else
              echo "No directory specified, staying in: $(pwd)"
            fi

            # Verify we're in the right place for Helm chart
            if [ ! -f "Chart.yaml" ]; then
              echo "ERROR: Chart.yaml not found in $(pwd)"
              echo "Looking for Chart.yaml in subdirectories:"
              find . -name "Chart.yaml" -type f 2>/dev/null || echo "No Chart.yaml found anywhere"
              exit 1
            fi

            echo "Found Chart.yaml - proceeding with Helm deployment"

            # Verify values file exists
            VALUES_FILE="${{ inputs.values }}"
            if [ ! -f "$VALUES_FILE" ]; then
              echo "ERROR: Values file '$VALUES_FILE' not found in $(pwd)"
              echo "Available YAML files:"
              ls -la *.yaml || echo "No YAML files found"
              exit 1
            fi

            echo "Found values file: $VALUES_FILE"
            echo "Values file size: $(wc -l < "$VALUES_FILE") lines"

            # Set database alias to match what was created
            DATABASE_ALIAS="${{ steps.vars.outputs.release }}"
            echo "Setting database alias to: $DATABASE_ALIAS"

            RELEASE_NAME="${{ steps.vars.outputs.release }}"
            
            # Function to perform helm upgrade with improved error handling
            perform_helm_upgrade() {
              local release_name="$1"
              local max_attempts=3
              local attempt=1

              while [ $attempt -le $max_attempts ]; do
                echo "Helm deployment attempt $attempt/$max_attempts..."
                echo "Release name: $release_name"
                echo "Chart directory: $(pwd)"
                
                # Verify files exist before each attempt
                echo "Verifying files before attempt $attempt:"
                echo "Chart file: $(ls -la ./tenant-management-system-*.tgz 2>/dev/null || echo 'NOT FOUND')"
                echo "Values file: $(ls -la "$VALUES_FILE" 2>/dev/null || echo 'NOT FOUND')"
                
                # Show the exact helm command that will be run
                echo "--- HELM COMMAND (Attempt $attempt) ---"
                echo "helm upgrade \\"
                echo "  --set-string global.repository=${{ github.repository }} \\"
                echo "  --set-string global.tag=\"${{ steps.vars.outputs.tag }}\" \\"
                echo "  --set-string global.config.databaseUser=\"${{ inputs.db_user }}\" \\"
                echo "  --set-string global.config.nodeEnv=${{ (inputs.environment == 'prod' || inputs.environment == 'production') && 'production' || (inputs.environment == 'test' && 'test' || 'development') }} \\"
                echo "  --set-string global.databaseAlias=\"$DATABASE_ALIAS\" \\"
                echo "  --set-string global.secrets.enabled=true \\"
                echo "  --set-string global.preserveDatabase=\"${{ inputs.preserve_database }}\" \\"
                echo "  ${{ inputs.params }} \\"
                echo "  --install --wait --timeout ${{ inputs.timeout-minutes }}m \\"
                echo "  --values \"$VALUES_FILE\" \\"
                echo "  \"$release_name\" \\"
                echo "  \"./tenant-management-system-${{ steps.pr.outputs.pr || steps.vars.outputs.version }}.tgz\""
                echo "---------------------------------------"

                # Attempt the upgrade with full output capture
                set +e  # Don't exit on error so we can capture output
                HELM_OUTPUT=$(helm upgrade \
                  --set-string global.repository=${{ github.repository }} \
                  --set-string global.tag="${{ steps.vars.outputs.tag }}" \
                  --set-string global.config.databaseUser="${{ inputs.db_user }}" \
                  --set-string global.config.nodeEnv=${{ (inputs.environment == 'prod' || inputs.environment == 'production') && 'production' || (inputs.environment == 'test' && 'test' || 'development') }} \
                  --set-string global.databaseAlias="$DATABASE_ALIAS" \
                  --set-string global.secrets.enabled=true \
                  --set-string global.preserveDatabase="${{ inputs.preserve_database }}" \
                  ${{ inputs.params }} \
                  --install --wait --timeout ${{ inputs.timeout-minutes }}m \
                  --values "$VALUES_FILE" \
                  --debug \
                  "$release_name" \
                  "./tenant-management-system-${{ steps.pr.outputs.pr || steps.vars.outputs.version }}.tgz" 2>&1)
                
                HELM_EXIT_CODE=$?
                set -e  # Re-enable exit on error
                
                echo "--- HELM OUTPUT (Attempt $attempt) ---"
                echo "$HELM_OUTPUT"
                echo "--- END HELM OUTPUT ---"
                echo "Helm exit code: $HELM_EXIT_CODE"

                if [ $HELM_EXIT_CODE -eq 0 ]; then
                  echo "Helm deployment completed successfully on attempt $attempt"
                  return 0
                else
                  echo "Helm deployment failed on attempt $attempt (exit code: $HELM_EXIT_CODE)"
                  
                  # Show additional debugging info
                  echo "--- POST-FAILURE DEBUG (Attempt $attempt) ---"
                  helm list || echo "Helm list failed"
                  oc get all -l app.kubernetes.io/instance="$release_name" || echo "No resources found"
                  echo "Working directory: $(pwd)"
                  echo "Files in directory:"
                  ls -la
                  echo "--- END POST-FAILURE DEBUG ---"

                  if [ $attempt -eq $max_attempts ]; then
                    echo "All attempts failed"
                    echo "FINAL HELM OUTPUT:"
                    echo "$HELM_OUTPUT"
                    return $HELM_EXIT_CODE
                  fi

                  echo "Cleaning up before retry..."
                  kubectl delete secret -l owner=helm,name="$release_name" --ignore-not-found=true --timeout=30s || true

                  echo "Waiting 15 seconds before retry..."
                  sleep 15
                  attempt=$((attempt + 1))
                fi
              done
            }

            # Helm package
            echo "Packaging Helm chart..."
            sed -i 's/^name:.*/name: ${{ github.event.repository.name }}/' Chart.yaml

            # Update dependencies to get the correct chart version
            echo "Updating Helm dependencies..."
            
            # Add Bitnami repo if not present
            helm repo add bitnami https://charts.bitnami.com/bitnami || true
            helm repo update
            
            # Clean any existing charts directory and lock file
            rm -rf charts/ || true
            rm -f Chart.lock || true
            
            # Update dependencies
            helm dependency update

            echo "Dependencies updated, packaging chart..."
            helm package . --app-version="tag-${{ steps.vars.outputs.tag }}_run-${{ github.run_number }}" --version=${{ steps.pr.outputs.pr || steps.vars.outputs.version }}
            
            echo "Chart packaged successfully:"
            ls -la ./tenant-management-system-*.tgz
            
            # Perform the deployment with retry logic
            perform_helm_upgrade "$RELEASE_NAME"

            # Helm release history
            helm history "$RELEASE_NAME" --max 5

            # Clean up completed pods
            oc delete po --field-selector=status.phase==Succeeded --ignore-not-found=true || true

      - name: Update secrets
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ inputs.oc_server }}
          commands: |
            # Get release name
            RELEASE="${{ inputs.release_name }}"
      
            # Wait for backend secret to exist (created by helm)
            echo "Waiting for backend secret to be created by helm..."
            for i in {1..30}; do
              if oc get secret $RELEASE-backend &>/dev/null; then
                echo "✅ Backend secret found"
                break
              fi
              echo "Attempt $i/30: Backend secret not found yet, waiting..."
              sleep 2
            done
      
            if ! oc get secret $RELEASE-backend &>/dev/null; then
              echo "❌ Backend secret was not created by helm"
              exit 1
            fi
      
            # Update secrets with real values
            echo "Updating backend secret with real SSO values..."
      
            # Set appropriate login proxy URL based on environment
            if [[ "${{ inputs.environment }}" == "prod" ]]; then
              LOGIN_PROXY="loginproxy.gov.bc.ca"
              ISSUER="https://loginproxy.gov.bc.ca/auth/realms/standard"
              JWKS_URI="https://loginproxy.gov.bc.ca/auth/realms/standard/protocol/openid-connect/certs"
            elif [[ "${{ inputs.environment }}" == "test" ]]; then
              LOGIN_PROXY="test.loginproxy.gov.bc.ca"  
              ISSUER="https://test.loginproxy.gov.bc.ca/auth/realms/standard"
              JWKS_URI="https://test.loginproxy.gov.bc.ca/auth/realms/standard/protocol/openid-connect/certs"
            else
              LOGIN_PROXY="dev.loginproxy.gov.bc.ca"
              ISSUER="https://dev.loginproxy.gov.bc.ca/auth/realms/standard"
              JWKS_URI="https://dev.loginproxy.gov.bc.ca/auth/realms/standard/protocol/openid-connect/certs"
            fi

            # Update client ID
            CLIENT_ID=$(echo -n "${{ secrets.bcgov_sso_api_client_id }}" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"BCGOV_SSO_API_CLIENT_ID":"'$CLIENT_ID'"}}'

            # Update client secret 
            CLIENT_SECRET=$(echo -n "${{ secrets.bcgov_sso_api_client_secret }}" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"BCGOV_SSO_API_CLIENT_SECRET":"'$CLIENT_SECRET'"}}'

            # Update issuer
            ISSUER_B64=$(echo -n "$ISSUER" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"ISSUER":"'$ISSUER_B64'"}}'

            # Update jwks uri
            JWKS_URI_B64=$(echo -n "$JWKS_URI" | base64 -w0)
            oc patch secret $RELEASE-backend \
              -p '{"data":{"JWKS_URI":"'$JWKS_URI_B64'"}}'

            echo "✅ Backend secret updated with real values"

            # Restart backend deployment to pick up new secrets
            if oc get deployment/$RELEASE-backend &>/dev/null; then
              echo "Restarting backend deployment..."
              oc rollout restart deployment/$RELEASE-backend
              echo "Waiting for backend deployment to complete..."
              oc rollout status deployment/$RELEASE-backend --timeout=300s
            else
              echo "Warning: Backend deployment not found: $RELEASE-backend"
            fi

            # Update frontend ConfigMap
            echo "Updating frontend configuration..."

            # Create frontend config JSON
            CONFIG_JSON=$(cat <<EOF
            {
              "api": {
                "baseUrl": "/api/v1"
              },
              "oidc": {
                "clientId": "${{ secrets.vite_keycloak_client_id }}",
                "realm": "standard",
                "serverUrl": "https://$LOGIN_PROXY/auth",
                "logoutUrl": "https://$LOGIN_PROXY/auth/realms/standard/protocol/openid-connect/logout"
              }
            }
            EOF
            )

            # Update frontend ConfigMap
            if oc get configmap $RELEASE-frontend-config &>/dev/null; then
              echo "Updating existing frontend ConfigMap..."
              oc delete configmap $RELEASE-frontend-config
            fi

            echo "$CONFIG_JSON" | oc create configmap $RELEASE-frontend-config --from-file=default.json=/dev/stdin

            echo "✅ Frontend ConfigMap updated"

            # Restart frontend deployment to pick up new config
            if oc get deployment/$RELEASE-frontend &>/dev/null; then
              echo "Restarting frontend deployment..."
              oc delete pods -l app.kubernetes.io/name=frontend,app.kubernetes.io/instance=$RELEASE
              echo "Waiting for frontend deployment to complete..."
              oc rollout status deployment/$RELEASE-frontend --timeout=300s
            else
              echo "Warning: Frontend deployment not found: $RELEASE-frontend"
            fi

            echo "✅ All secrets and configurations updated successfully"


      - name: Update Database Password for PR Environments
        if: contains(steps.vars.outputs.release, '-pr-')
        uses: bcgov/action-oc-runner@10033668ef4374d9bb78149faa73e4ccda0e93dd
        with:
          oc_namespace: ${{ secrets.oc_namespace }}
          oc_token: ${{ secrets.oc_token }}
          oc_server: ${{ inputs.oc_server }}
          commands: |
            set -euo pipefail
      
            RELEASE_NAME="${{ steps.vars.outputs.release }}"
            DB_USER="${{ inputs.db_user }}"
            DB_SECRET_NAME="${RELEASE_NAME}-pguser-${DB_USER}"
      
            echo "Updating database password for PR environment..."
            echo "Release: $RELEASE_NAME"
            echo "DB User: $DB_USER"
            echo "Expected DB Secret: $DB_SECRET_NAME"
      
            # Wait for the database secret to exist
            for i in {1..60}; do
              if oc get secret "$DB_SECRET_NAME" &>/dev/null; then
                echo "Database secret found: $DB_SECRET_NAME"
                break
              fi
              echo "Attempt $i/60: Database secret not found yet, waiting..."
              sleep 5
            done
      
            if ! oc get secret "$DB_SECRET_NAME" &>/dev/null; then
              echo "Database secret not found: $DB_SECRET_NAME"
              echo "Available secrets:"
              oc get secrets | grep -E "(pguser|postgres)" || echo "No database secrets found"
              exit 1
            fi
      
            # Get the real database password
            DB_PASSWORD=$(oc get secret "$DB_SECRET_NAME" -o jsonpath='{.data.password}')
            if [ -z "$DB_PASSWORD" ]; then
              echo "Database password not found in secret"
              exit 1
            fi
      
            echo "Found database password, updating backend secret..."
      
            # Update the backend secret with the real database password
            oc patch secret "${RELEASE_NAME}-backend" \
              -p '{"data":{"POSTGRES_PASSWORD":"'$DB_PASSWORD'"}}'
      
            # Update the flyway secret with the real database password
            oc patch secret "${RELEASE_NAME}-flyway" \
              -p '{"data":{"FLYWAY_PASSWORD":"'$DB_PASSWORD'"}}'
      
            echo "Database password updated successfully"

      - name: Update deployment status
        uses: bobheadxi/deployments@v1.4.0
        if: always() && steps.deployment.outputs.deployment_id
        with:
          step: finish
          token: ${{ github.token }}
          status: ${{ job.status }}
          env: ${{ inputs.environment || 'dev' }}
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
          env_url: ${{ inputs.deployment_url }}

      - name: Log deployment status (fallback)
        if: always() && !steps.deployment.outputs.deployment_id
        run: |
          echo "⚠️ Deployment tracking was not initialized properly"
          echo "Job status: ${{ job.status }}"
          echo "Environment: ${{ inputs.environment || 'dev' }}"
          echo "URL: ${{ inputs.deployment_url }}"